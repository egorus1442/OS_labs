# Лабораторная работа №4 по операционным системам
---

## Сборка:
```
make
```

## Запуск:
```
./test_dinamic
./test_static
```
---

## О лабе:


### Реализация динамических библиотек

Были созданы две динамические библиотеки:

libprime.so — содержит функции для подсчёта простых чисел на отрезке [A, B].
libpi.so — содержит функции для вычисления числа Пи.
Функции в библиотеках:

PrimeCountNaive — наивный алгоритм подсчёта простых чисел.
PrimeCountEratosthenes — алгоритм "Решето Эратосфена".
PiLeibniz — вычисление числа Пи с использованием ряда Лейбница.
PiWallis — вычисление числа Пи с использованием формулы Валлиса.

### Тестовая программа №1 (статическая линковка)

Программа №1 использует библиотеки на этапе компиляции. Это означает, что код библиотек включается в исполняемый файл, и программа не зависит от внешних библиотек во время выполнения.

Особенности:

Реализация функций фиксирована (используются PrimeCountNaive и PiLeibniz).
Невозможно переключить реализацию во время выполнения.
Программа выводит информацию о том, какая реализация была использована.
Пример работы:

```
Copy
Input program code:
 1 -> PrimeCount
 2 -> Pi
-1 -> Exit
1
Enter A and B: 1 10
PrimeCount(1, 10) = 4
Implementation used: Naive
```

### Тестовая программа №2 (динамическая загрузка)

Программа №2 загружает библиотеки во время выполнения с использованием функций dlopen, dlsym и dlclose. Это позволяет:

Переключать реализации функций во время выполнения.
Загружать библиотеки по относительным путям.
Особенности:

Реализация функций может быть изменена при вводе команды 0.
Программа выводит информацию о текущей реализации.
Пример работы:

```
Copy
Input program code:
 0 -> Library switch
 1 -> PrimeCount
 2 -> Pi
-1 -> Exit
0
Library switched successfully!
Current PrimeCount implementation: Eratosthenes
Current Pi implementation: Wallis

Input program code:
 0 -> Library switch
 1 -> PrimeCount
 2 -> Pi
-1 -> Exit
1
Enter A and B: 1 10
PrimeCount(1, 10) = 4
Implementation used: Eratosthenes
```

### Переключение реализаций

В программе №2 реализована возможность переключения между реализациями функций:

Для PrimeCount переключаются Naive и Eratosthenes.
Для Pi переключаются Leibniz и Wallis.
Переключение происходит при вводе команды 0. Программа выводит сообщение о текущей реализации.

### Пользовательский ввод

Пользовательский ввод организован следующим образом:

0 — переключение реализаций (только для программы №2).
1 arg1 arg2 — вызов функции PrimeCount с аргументами arg1 и arg2.
2 arg1 — вызов функции Pi с аргументом arg1.
-1 — завершение программы.

### Анализ работы
### Сравнение статической и динамической линковки

Статическая линковка:
Преимущества: Простота, высокая производительность.
Недостатки: Невозможность переключения реализаций, увеличенный размер исполняемого файла.
Динамическая линковка:
Преимущества: Гибкость, возможность переключения реализаций, экономия памяти.
Недостатки: Зависимость от окружения, накладные расходы на загрузку библиотек.
3
### Выводы

Программа №1 демонстрирует использование статической линковки. Она проста в использовании, но не поддерживает переключение реализаций.
Программа №2 демонстрирует использование динамической линковки. Она более гибкая, но требует дополнительных усилий для загрузки и управления библиотеками.

### Заключение

В ходе выполнения лабораторной работы были изучены и применены на практике следующие концепции:

Создание и использование динамических библиотек.
Статическая и динамическая линковка.
Переключение реализаций функций во время выполнения.
Работа демонстрирует преимущества и недостатки каждого подхода, а также предоставляет готовые решения для использования динамических библиотек в реальных проектах.

## Теория (динамические и статические библиотеки):

### Динамические библиотеки

Динамические библиотеки — это скомпилированные фрагменты кода, которые могут быть загружены в память и использованы программой во время её выполнения. Они позволяют:

Разделять код между несколькими программами.
Уменьшать размер исполняемых файлов.
Упрощать обновления, так как библиотеки могут быть заменены без перекомпиляции основной программы.
Преимущества динамических библиотек:

Гибкость: Библиотеки могут быть загружены и выгружены во время выполнения.
Экономия памяти: Одна библиотека может использоваться несколькими программами одновременно.
Упрощение обновлений: Достаточно обновить библиотеку, не перекомпилируя основную программу.
Недостатки динамических библиотек:

Зависимость от окружения: Программа может не запуститься, если библиотека отсутствует или несовместима.
Накладные расходы: Динамическая загрузка требует дополнительных ресурсов.


### Статическая и динамическая линковка

Статическая линковка: Код библиотеки включается в исполняемый файл на этапе компиляции. Программа становится самодостаточной, но её размер увеличивается.

Динамическая линковка: Библиотеки загружаются в память во время выполнения программы. Это позволяет переключать реализации и экономить память.

### dlopen, dlsym, dlclose

Функции dlopen, dlsym и dlclose являются частью библиотеки libdl и предоставляют интерфейс для динамической загрузки и использования разделяемых библиотек (shared libraries) во время выполнения программы. Эти функции позволяют загружать библиотеки, получать указатели на функции и символы, а также выгружать библиотеки из памяти.

### Функция dlopen

Описание:

Функция dlopen загружает динамическую библиотеку в память и возвращает указатель на неё. Этот указатель используется для доступа к символам (функциям или переменным) в библиотеке.

Сигнатура:


```void *dlopen(const char *filename, int flags);```

Параметры:

- filename: Путь к динамической библиотеке (например, "./libmylib.so"). Если передать NULL, будет загружена основная программа.
- flags: Флаги, определяющие режим загрузки библиотеки. Основные флаги:
    - RTLD_LAZY: Отложенное разрешение символов. Символы разрешаются только при первом использовании.
    - RTLD_NOW: Немедленное разрешение всех символов при загрузке библиотеки.
    - RTLD_GLOBAL: Символы из этой библиотеки будут доступны для других загружаемых библиотек.
    - RTLD_LOCAL: Символы из этой библиотеки не будут доступны для других загружаемых библиотек (по умолчанию).

Возвращаемое значение:

В случае успеха возвращается указатель на загруженную библиотеку.
В случае ошибки возвращается NULL, и дополнительную информацию можно получить с помощью функции dlerror.
Пример

```
void *handle = dlopen("./libmylib.so", RTLD_LAZY);
if (!handle) {
    fprintf(stderr, "Ошибка загрузки библиотеки: %s\n", dlerror());
    exit(1); 
}
```

### Функция dlsym

Описание:

Функция dlsym возвращает указатель на символ (функцию или переменную) из загруженной библиотеки.

Сигнатура:


```void *dlsym(void *handle, const char *symbol);```

Параметры:

- handle: Указатель на загруженную библиотеку, возвращённый dlopen.
- symbol: Имя символа (функции или переменной), который нужно найти.
  

Возвращаемое значение:

- В случае успеха возвращается указатель на символ.
- В случае ошибки возвращается NULL, и дополнительную информацию можно получить с помощью функции dlerror.

Пример:


```
void (*my_function)() = dlsym(handle, "my_function");
if (!my_function) {
    fprintf(stderr, "Ошибка загрузки символа: %s\n", dlerror());
    dlclose(handle);
    exit(1);
}
my_function(); // Вызов функции из библиотеки
```

### Функция dlclose

Описание:

Функция dlclose выгружает динамическую библиотеку из памяти. Если библиотека больше не используется, её ресурсы освобождаются.

Сигнатура:

```int dlclose(void *handle);```

Параметры:

- handle: Указатель на загруженную библиотеку, возвращённый dlopen.

Возвращаемое значение: 

- В случае успеха возвращается 0.
- В случае ошибки возвращается ненулевое значение, и дополнительную информацию можно получить с помощью функции dlerror.

Пример:

```
if (dlclose(handle) != 0) {
    fprintf(stderr, "Ошибка выгрузки библиотеки: %s\n", dlerror());
    exit(1);
}
```
### Функция dlerror

Описание:

Функция dlerror возвращает строку с описанием последней ошибки, произошедшей при вызове dlopen, dlsym или dlclose.

Сигнатура:

char *dlerror(void);

Возвращаемое значение:

- Если ошибки не было, возвращается NULL.
- Если ошибка произошла, возвращается строка с описанием ошибки.

Пример:

```
void *handle = dlopen("./libmylib.so", RTLD_LAZY);
if (!handle) {
    fprintf(stderr, "Ошибка загрузки библиотеки: %s\n", dlerror());
    exit(1);
}
```

## Теория (работа с памятью, аллокация) (лучше почитать "UNIX изнутри" Вахалии со стр. 540)

### 1. Распределитель памяти ядра
   1. Частое выделение/освобождение структур
* В ядре операционной системы часто требуется выделять и освобождать память для различных структур данных (например, дескрипторы процессов, файловые дескрипторы и т.д.).
* Это требует эффективного управления памятью, чтобы минимизировать накладные расходы и избежать фрагментации.

1\.2 Необходимость динамического выделения объектов

* Динамическое выделение памяти позволяет ядру адаптироваться к изменяющимся требованиям системы.
* Это особенно важно для объектов, которые создаются и уничтожаются в процессе работы системы.

1\.3 Обработка ситуации, когда нет памяти

* Заблокировать вызывающий процесс: Если память недоступна, процесс может быть заблокирован до тех пор, пока память не станет доступной.
* Вернуться с ошибкой без блокировки: В некоторых случаях, если память недоступна, система может вернуть ошибку, чтобы процесс мог обработать эту ситуацию.

1\.4 Отслеживание свободных частей и уменьшение фрагментации

* Распределитель памяти должен отслеживать свободные участки памяти, чтобы эффективно их использовать.
* Уменьшение фрагментации достигается за счет слияния соседних свободных блоков и использования различных стратегий выделения памяти.

### 2\. Аллокаторы. Оценка аллокаторов 

Аллокаторы - это компонент операционной системы или программы, который управляет выделением и освобождением памяти. Он отвечает за эффективное распределение памяти между процессами или объектами, минимизацию фрагментации и оптимизацию производительности при работе с динамической памятью.

2\.1 Фактор использования

* Фактор использования определяется как отношение запрашиваемой памяти к общей выделенной памяти:

* Чем ближе этот показатель к 1, тем эффективнее используется память.

2\.2 Скорость выделения/освобождения памяти

* Важным критерием является скорость, с которой аллокатор может выделять и освобождать память.
* Это особенно важно в системах реального времени, где задержки недопустимы.

2\.3 Простота использования аллокатора

* Аллокатор должен быть прост в использовании и интеграции в существующую систему.
* Это включает в себя удобный интерфейс и минимальные требования к настройке.

### 3\. Способы отслеживания свободной памяти

3\.1 Битовая матрица

* Каждый бит в матрице соответствует определенному блоку памяти.
* Если бит установлен, блок занят, иначе свободен.

3\.2 Связанные списки

* Свободные блоки памяти организуются в связанные списки.
* Каждый блок содержит информацию о своем размере и ссылку на следующий свободный блок.

### 4\. Виды аллокаторов

4\.1 Список свободных элементов

Аллокатор, который организует свободные блоки памяти в список. При выделении памяти выбирается подходящий блок из списка, при освобождении — блок возвращается в список.

* Свободные блоки организуются в список.
* При выделении памяти выбирается подходящий блок из списка.
* При освобождении блок добавляется обратно в список.

4\.2 Выделение памяти по степени 2

Аллокатор, который делит память на блоки, размер которых равен степени 2 (например, 8, 16, 32 байта). Это упрощает выделение и освобождение памяти, но может приводить к внутренней фрагментации.
* Память делится на блоки, размер которых равен степени 2.
* Это упрощает выделение и освобождение памяти, но может привести к внутренней фрагментации.

4\.3 Алгоритм Мак-Кьюзи-Кэрелса

Улучшенная версия аллокатора по степени 2, которая использует массивы страниц и списки свободных блоков для более эффективного управления памятью.

* Улучшенная версия алгоритма выделения памяти по степени 2.
* Использует массивы страниц и списки свободных блоков для более эффективного управления памятью.

4\.4 Алгоритм двойников

Аллокатор, который делит память на блоки, которые могут быть разделены на более мелкие блоки (двойники). При освобождении блоков, если соседний блок свободен, они объединяются.

* Память делится на блоки, которые могут быть разделены на более мелкие блоки (двойники).
* При освобождении блоков, если соседний блок свободен, они объединяются.

4\.5 Слябовый аллокатор

Аллокатор, предназначенный для управления объектами фиксированного размера. Память разделяется на слябы (группы страниц), которые содержат объекты. При создании объекта используется свободный объект из сляба.

* Используется для управления объектами фиксированного размера.
* Память разделяется на слябы, которые содержат объекты. При создании объекта используется свободный объект из сляба.

### 5\. Список свободных элементов: основные положения

5\.1 Организация свободных блоков в список

* Свободные блоки памяти организуются в список, где каждый блок содержит информацию о своем размере и ссылку на следующий свободный блок.

5\.2 Стратегии выбора свободного блока

* Первое подходящее: Выбирается первый блок, который подходит по размеру.
* Следующее подходящее: Выбирается следующий блок после последнего выделенного.
* Наиболее подходящее: Выбирается блок, который наиболее точно соответствует запрашиваемому размеру.
* Наименее подходящее: Выбирается самый большой блок, который может удовлетворить запрос.

### 6\. Алгоритм выделения/освобождения памяти

6\.1 Выделение памяти

* Находим подходящий блок памяти.
* Уменьшаем его размер на запрашиваемый размер.

6\.2 Освобождение памяти

* Находим место для вставки освобожденного блока.
* При необходимости производим слияние соседних блоков.
* Сложность операции освобождения в односвязном списке — O(n).

### 7\. Улучшения

7\.1 Хранение размера занятого блока

* Если есть свободный блок длиной N+1, нельзя выделить из него блок длиной N.

7\.2 Использование двусвязного списка

* В занятом блоке хранится размер, тег «занят» в начале и конце блока.
* В свободном блоке хранится размер, ссылки на следующий и предыдущий свободные блоки, тег «свободен» в начале и конце блока.

### 8\. Анализ аллокатора: «список свободных элементов»

8\.1 Плюсы

* Простота реализации.
* Можно выделять ровно запрошенное количество байт.
* Можно освобождать меньше, чем размер занятого блока.
* Есть слияние свободных блоков.

8\.2 Минусы

* Большая фрагментация при длительной работе.
* Для ускорения требуется значительное количество дополнительной памяти.

### 9\. Выделение памяти по степени 2: анализ

9\.1 Плюсы

* Удобный интерфейс для free().
* Быстрый поиск ресурса для выделения.

9\.2 Минусы

* Использование лишней памяти.
* В занятой памяти хранится указатель на голову списка.
* Нельзя освобождать буферы частично.
* Нет слияния буфера и возвращение памяти страничному аллокатору.

### 10\. Алгоритм Мак-Кьюзи-Кэрелса:

Анализ:

10\.1 Плюсы

* Блоки можно выделять нужного размера.
* Блоки формируются по требованиям системы.
* Функция free не требует размера освобождаемого блока.

10\.2 Минусы

* Нет возможности возвращать страницы обратно страничному аллокатору.
* Нет возможности слияния блоков.
* Возможны потери при неравномерном распределении запрашиваемых размеров памяти.

### 11\. Алгоритм двойников: анализ и улучшения

11\.1 Плюсы

* Объединение смежных блоков.
* Легко обмениваться со страничным аллокатором.

11\.2 Минусы

* При частом выделении/освобождении падает производительность из-за слияния.
* При удалении необходимо указывать размер блока.
* Можно выделить только блок кратный степени 2.

11\.3 Улучшения

* Отложенное слияние, только если slack < 2.

### 12\. Слябовый аллокатор

12\.1 Цикл жизни объекта

* Создание – использование – уничтожение – освобождение.
* Возможно повторное использование объектов без инициализации.

12\.2 Организация памяти

* Объекты ядра делятся на группы-кэши, кэш делится на слябы.
* Слябы содержат объекты, и при создании объекта используется свободный объект из сляба.

