# Лабораторная работа №2


## Сборка лабы:
```
gcc timsort2.c -o parent

```

## Запуск
```
./timsort2[количество потоков]
```

## Краткая теория:

### Потоки (Потоки выполнения)
1. Разновидность процесса внутри процесса
2. При старте у каждого процесса есть единственный поток управления

#### Необходимость в потоках
1. Упрощение модели программирования, когда в одной программе может
выполняться несколько действий сразу
2. Создание потоков быстрее, чем создание процессов
3. Эффективность их использования в мультипроцессорных системах

#### Реализация многозадачности сервера
1. Потоки
2. Однопоточный процесс
3. Машина с конечным числом состояний


#### ЭЛЕМЕНТЫ, ПРИСУЩИЕ ПОТОКАМ
1. Счетчик команд
2. Регистры
3. Стек
4. Состояние

#### Стратегии реализации потоков

1. В пользовательском пространстве

Потоки реализуются полностью в пользовательском пространстве, без участия ядра операционной системы.
Управление потоками осуществляется библиотекой, работающей в пользовательском пространстве.
Быстрое создание и уничтожение потоков.
Низкие накладные расходы на переключение контекста.
Потоки не могут использовать многопроцессорные системы эффективно, так как ядро не знает о существовании потоков.
Блокировка одного потока может привести к блокировке всех потоков в процессе.
1. В ядре

Потоки реализуются на уровне ядра операционной системы.
Ядро управляет созданием, уничтожением и планированием потоков.
Потоки могут использовать многопроцессорные системы эффективно.
Блокировка одного потока не приводит к блокировке всех потоков в процессе.
Высокие накладные расходы на создание и уничтожение потоков.
Высокие накладные расходы на переключение контекста.
1. Гибридный способ

Комбинация пользовательских и ядерных потоков.
Комбинация пользовательских и ядерных потоков.
Пользовательские потоки (легковесные потоки) управляются библиотекой в пользовательском пространстве, а ядерные потоки управляются ядром операционной системы.
Сложность реализации и управления.
Возможные проблемы с синхронизацией между пользовательскими и ядерными потоками.

---
### pthread_t

pthread_t — это тип данных, который используется для хранения идентификатора потока (thread) в многопоточных программах. Поток — это отдельная последовательность выполнения кода, которая может работать параллельно с другими потоками в рамках одной программы.

#### pthread_create — создание потока

```
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```
<b>Параметры:</b>

- pthread_t *thread
Указатель на переменную типа pthread_t, в которую будет записан идентификатор созданного потока.
- const pthread_attr_t *attr
Указатель на структуру, которая задает атрибуты потока (например, размер стека, приоритет и т.д.). Если передать NULL, будут использованы атрибуты по умолчанию.
void *(*start_routine) (void *)
- Указатель на функцию, которая будет выполняться в новом потоке. Эта функция должна принимать один аргумент типа void* и возвращать значение типа void*.
void *arg
- Аргумент, который будет передан в функцию start_routine. Если аргументов нет, можно передать NULL.
  
<b>Возвращаемое значение:</b>

0 — если поток успешно создан.
Ненулевое значение — если произошла ошибка.

#### pthread_join — ожидание завершения потока

```
int pthread_join(pthread_t thread, void **retval);
```
<b>Параметры:</b>

- pthread_t thread
Идентификатор потока, завершения которого мы ждем.
- void **retval
Указатель на переменную, в которую будет записано возвращаемое значение потока (то, что вернула функция start_routine). Если возвращаемое значение не нужно, можно передать NULL.

<b>Возвращаемое значение:</b>

0 — если поток успешно завершен.
Ненулевое значение — если произошла ошибка.